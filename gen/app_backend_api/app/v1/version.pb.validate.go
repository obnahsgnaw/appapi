// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: app_backend_api/app/v1/version.proto

package appv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AppVersionPaginateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionPaginateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionPaginateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionPaginateRequestMultiError, or nil if none found.
func (m *AppVersionPaginateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionPaginateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() < 0 {
		err := AppVersionPaginateRequestValidationError{
			field:  "Page",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() < 0 {
		err := AppVersionPaginateRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Keyword

	// no validation rules for Sort

	if utf8.RuneCountInString(m.GetAppId()) != 24 {
		err := AppVersionPaginateRequestValidationError{
			field:  "AppId",
			reason: "value length must be 24 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return AppVersionPaginateRequestMultiError(errors)
	}

	return nil
}

// AppVersionPaginateRequestMultiError is an error wrapping multiple validation
// errors returned by AppVersionPaginateRequest.ValidateAll() if the
// designated constraints aren't met.
type AppVersionPaginateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionPaginateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionPaginateRequestMultiError) AllErrors() []error { return m }

// AppVersionPaginateRequestValidationError is the validation error returned by
// AppVersionPaginateRequest.Validate if the designated constraints aren't met.
type AppVersionPaginateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionPaginateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionPaginateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionPaginateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionPaginateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionPaginateRequestValidationError) ErrorName() string {
	return "AppVersionPaginateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionPaginateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionPaginateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionPaginateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionPaginateRequestValidationError{}

// Validate checks the field values on AppVersionDetailRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionDetailRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionDetailRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionDetailRequestMultiError, or nil if none found.
func (m *AppVersionDetailRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionDetailRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := AppVersionDetailRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAppId()) != 24 {
		err := AppVersionDetailRequestValidationError{
			field:  "AppId",
			reason: "value length must be 24 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return AppVersionDetailRequestMultiError(errors)
	}

	return nil
}

// AppVersionDetailRequestMultiError is an error wrapping multiple validation
// errors returned by AppVersionDetailRequest.ValidateAll() if the designated
// constraints aren't met.
type AppVersionDetailRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionDetailRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionDetailRequestMultiError) AllErrors() []error { return m }

// AppVersionDetailRequestValidationError is the validation error returned by
// AppVersionDetailRequest.Validate if the designated constraints aren't met.
type AppVersionDetailRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionDetailRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionDetailRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionDetailRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionDetailRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionDetailRequestValidationError) ErrorName() string {
	return "AppVersionDetailRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionDetailRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionDetailRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionDetailRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionDetailRequestValidationError{}

// Validate checks the field values on AppVersionCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionCreateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionCreateRequestMultiError, or nil if none found.
func (m *AppVersionCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAppId()) != 24 {
		err := AppVersionCreateRequestValidationError{
			field:  "AppId",
			reason: "value length must be 24 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if m.GetData() == nil {
		err := AppVersionCreateRequestValidationError{
			field:  "Data",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppVersionCreateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppVersionCreateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppVersionCreateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppVersionCreateRequestMultiError(errors)
	}

	return nil
}

// AppVersionCreateRequestMultiError is an error wrapping multiple validation
// errors returned by AppVersionCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type AppVersionCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionCreateRequestMultiError) AllErrors() []error { return m }

// AppVersionCreateRequestValidationError is the validation error returned by
// AppVersionCreateRequest.Validate if the designated constraints aren't met.
type AppVersionCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionCreateRequestValidationError) ErrorName() string {
	return "AppVersionCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionCreateRequestValidationError{}

// Validate checks the field values on AppVersionFormData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionFormData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionFormData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionFormDataMultiError, or nil if none found.
func (m *AppVersionFormData) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionFormData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
		err := AppVersionFormDataValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 255 {
		err := AppVersionFormDataValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 5 || l > 20 {
		err := AppVersionFormDataValidationError{
			field:  "Version",
			reason: "value length must be between 5 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetVersionNum() <= 0 {
		err := AppVersionFormDataValidationError{
			field:  "VersionNum",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	if l := utf8.RuneCountInString(m.GetUrl()); l < 1 || l > 255 {
		err := AppVersionFormDataValidationError{
			field:  "Url",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AppVersionFormDataMultiError(errors)
	}

	return nil
}

// AppVersionFormDataMultiError is an error wrapping multiple validation errors
// returned by AppVersionFormData.ValidateAll() if the designated constraints
// aren't met.
type AppVersionFormDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionFormDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionFormDataMultiError) AllErrors() []error { return m }

// AppVersionFormDataValidationError is the validation error returned by
// AppVersionFormData.Validate if the designated constraints aren't met.
type AppVersionFormDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionFormDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionFormDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionFormDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionFormDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionFormDataValidationError) ErrorName() string {
	return "AppVersionFormDataValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionFormDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionFormData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionFormDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionFormDataValidationError{}

// Validate checks the field values on AppVersionUpdateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionUpdateRequestMultiError, or nil if none found.
func (m *AppVersionUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := AppVersionUpdateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAppId()) != 24 {
		err := AppVersionUpdateRequestValidationError{
			field:  "AppId",
			reason: "value length must be 24 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if m.GetData() == nil {
		err := AppVersionUpdateRequestValidationError{
			field:  "Data",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppVersionUpdateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppVersionUpdateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppVersionUpdateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppVersionUpdateRequestMultiError(errors)
	}

	return nil
}

// AppVersionUpdateRequestMultiError is an error wrapping multiple validation
// errors returned by AppVersionUpdateRequest.ValidateAll() if the designated
// constraints aren't met.
type AppVersionUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionUpdateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionUpdateRequestMultiError) AllErrors() []error { return m }

// AppVersionUpdateRequestValidationError is the validation error returned by
// AppVersionUpdateRequest.Validate if the designated constraints aren't met.
type AppVersionUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionUpdateRequestValidationError) ErrorName() string {
	return "AppVersionUpdateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionUpdateRequestValidationError{}

// Validate checks the field values on AppVersionUpdateData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionUpdateData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionUpdateData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionUpdateDataMultiError, or nil if none found.
func (m *AppVersionUpdateData) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionUpdateData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetData() == nil {
		err := AppVersionUpdateDataValidationError{
			field:  "Data",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppVersionUpdateDataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppVersionUpdateDataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppVersionUpdateDataValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetConflict() == nil {
		err := AppVersionUpdateDataValidationError{
			field:  "Conflict",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConflict()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppVersionUpdateDataValidationError{
					field:  "Conflict",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppVersionUpdateDataValidationError{
					field:  "Conflict",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConflict()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppVersionUpdateDataValidationError{
				field:  "Conflict",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppVersionUpdateDataMultiError(errors)
	}

	return nil
}

// AppVersionUpdateDataMultiError is an error wrapping multiple validation
// errors returned by AppVersionUpdateData.ValidateAll() if the designated
// constraints aren't met.
type AppVersionUpdateDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionUpdateDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionUpdateDataMultiError) AllErrors() []error { return m }

// AppVersionUpdateDataValidationError is the validation error returned by
// AppVersionUpdateData.Validate if the designated constraints aren't met.
type AppVersionUpdateDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionUpdateDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionUpdateDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionUpdateDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionUpdateDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionUpdateDataValidationError) ErrorName() string {
	return "AppVersionUpdateDataValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionUpdateDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionUpdateData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionUpdateDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionUpdateDataValidationError{}

// Validate checks the field values on AppVersionDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionDeleteRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionDeleteRequestMultiError, or nil if none found.
func (m *AppVersionDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := AppVersionDeleteRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAppId()) != 24 {
		err := AppVersionDeleteRequestValidationError{
			field:  "AppId",
			reason: "value length must be 24 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return AppVersionDeleteRequestMultiError(errors)
	}

	return nil
}

// AppVersionDeleteRequestMultiError is an error wrapping multiple validation
// errors returned by AppVersionDeleteRequest.ValidateAll() if the designated
// constraints aren't met.
type AppVersionDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionDeleteRequestMultiError) AllErrors() []error { return m }

// AppVersionDeleteRequestValidationError is the validation error returned by
// AppVersionDeleteRequest.Validate if the designated constraints aren't met.
type AppVersionDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionDeleteRequestValidationError) ErrorName() string {
	return "AppVersionDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionDeleteRequestValidationError{}

// Validate checks the field values on AppVersionPublishRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppVersionPublishRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersionPublishRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppVersionPublishRequestMultiError, or nil if none found.
func (m *AppVersionPublishRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersionPublishRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := AppVersionPublishRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAppId()) != 24 {
		err := AppVersionPublishRequestValidationError{
			field:  "AppId",
			reason: "value length must be 24 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if m.GetData() == nil {
		err := AppVersionPublishRequestValidationError{
			field:  "Data",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppVersionPublishRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppVersionPublishRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppVersionPublishRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppVersionPublishRequestMultiError(errors)
	}

	return nil
}

// AppVersionPublishRequestMultiError is an error wrapping multiple validation
// errors returned by AppVersionPublishRequest.ValidateAll() if the designated
// constraints aren't met.
type AppVersionPublishRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionPublishRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionPublishRequestMultiError) AllErrors() []error { return m }

// AppVersionPublishRequestValidationError is the validation error returned by
// AppVersionPublishRequest.Validate if the designated constraints aren't met.
type AppVersionPublishRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionPublishRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionPublishRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionPublishRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionPublishRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionPublishRequestValidationError) ErrorName() string {
	return "AppVersionPublishRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppVersionPublishRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersionPublishRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionPublishRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionPublishRequestValidationError{}
